const {
  Client,
  Intents,
  MessageAttachment,
  MessageEmbed,
  Permissions,
  MessageActionRow,
  MessageSelectMenu,
  MessageButton,
  GatewayIntentBits,
  EmbedBuilder,
  ContextMenuCommandBuilder,
  ApplicationCommandType,
  ActionRowBuilder,
  StringSelectMenuBuilder,
  IntentsBitField,
  Guild,
  GuildMember,
  ApplicationCommandOptionType,
  MessageMentions,
  MessageActionRowOptions,
  MessageSelectMenuOptions,
  Presence,
  UserFlags,
  AttachmentBuilder,
  Colors,
  ButtonBuilder,
  ButtonStyle,
  PermissionFlagsBits,
  WebhookClient,
  version: discordVersion,
} = require("discord.js");
const Discord = require("discord.js");
const dotenv = require("dotenv");
dotenv.config();
require("dotenv").config();
const fs = require("fs");
const options = {
  intents: [
    "Guilds",
    "GuildBans",
    "GuildMessages",
    "GuildMessageReactions",
    "GuildChannels,",
    "GuildPresences",
    "MessageContent",
    "GatewayIntentBits.GuildVoiceStates",
    "GatewayIntentBits.GuildMembers",
    "IntentsBitField.Flags.GuildMessages",
    "IntentsBitField.Flags.MessageContent",
    "DirectMessages",
    "DirectMessageReactions",
    "DirectMessageTyping",
    "GuildPresences",
    "Discord.Intents.FLAGS.GUILDS",
    "Discord.Intents.FLAGS.GUILD_MESSAGES",
    "Discord.Intents.FLAGS.GUILD_MESSAGE_REACTIONS",
  ],
};
const client = new Client({
  partials: ["CHANNEL"],
  intents: new Intents(32767),
});
//„Åì„Åì„Åã„Çâ
client.once("ready", async () => {
  try {
    const command = await client.application.commands.create({
      name: "rp-create",
      description: "„É≠„Éº„É´„Éë„Éç„É´„ÇíÊñ∞„Åó„Åè‰ΩúÊàê„Åó„Åæ„Åô",
      options: [
        {
          name: "role",
          description: "„Éë„Éç„É´„Å´ÊúÄÂàù„Å´ËøΩÂä†„Åô„Çã„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: true,
        },
        {
          name: "title",
          description:
            "„Éë„Éç„É´„ÅÆ„Çø„Ç§„Éà„É´„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ(ÊåáÂÆöÁÑ°„Åó„ÅÆÂ†¥Âêà„ÅÆ„Çø„Ç§„Éà„É´:ÂΩπËÅ∑„Éë„Éç„É´)",
          type: "STRING",
          required: false,
        },
        {
          name: "description",
          description:
            "„Éë„Éç„É´„ÅÆË™¨Êòé„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ(ÊåáÂÆöÁÑ°„Åó„ÅÆÂ†¥ÂêàË™¨Êòé„ÅØË®òËºâ„Åï„Çå„Åæ„Åõ„Çì)",
          type: "STRING",
          required: false,
        },
      ],
    });
  } catch (error) {
    console.error(error);
  }
});

client.once("ready", async () => {
  try {
    await client.application.commands.create({
      name: "rp-add",
      description: "„É≠„Éº„É´„Éë„Éç„É´„Å´„É≠„Éº„É´„ÇíËøΩÂä†„Åó„Åæ„Åô",
      options: [
        {
          name: "messageid",
          description: "ËøΩÂä†„Åô„Çã„Éë„Éç„É´„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ID„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "STRING",
          required: true,
        },
        {
          name: "role",
          description: "ËøΩÂä†„Åô„Çã„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: true,
        },
        {
          name: "role2",
          description: "ËøΩÂä†„Åô„Çã2Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role3",
          description: "ËøΩÂä†„Åô„Çã3Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role4",
          description: "ËøΩÂä†„Åô„Çã4Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role5",
          description: "ËøΩÂä†„Åô„Çã5Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role6",
          description: "ËøΩÂä†„Åô„Çã6Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role7",
          description: "ËøΩÂä†„Åô„Çã7Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role8",
          description: "ËøΩÂä†„Åô„Çã8Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role9",
          description: "ËøΩÂä†„Åô„Çã9Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
        {
          name: "role10",
          description: "ËøΩÂä†„Åô„Çã10Áï™ÁõÆ„ÅÆ„É≠„Éº„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
          type: "ROLE",
          required: false,
        },
      ],
    });
    console.log("Bot is ready and slash commands are registered.");
  } catch (error) {
    console.error(error);
  }
});

client.on("messageCreate", async (message) => {
  if (message.content.startsWith("r.createpanel")) {
    const roleMentions = message.mentions.roles;
    if (roleMentions.size === 0)
      return message.reply("„É≠„Éº„É´„Çí„É°„É≥„Ç∑„Éß„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ");

    const roleOrder = message.content
      .match(/<@&(\d+)>/g)
      .map((match) => match.match(/\d+/)[0]);
    const roles = roleOrder.map((roleId) => roleMentions.get(roleId).id);

    const embed = new MessageEmbed()
      .setColor("#0099ff")
      .setTitle("„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„É≠„Éº„É´")
      .setDescription(
        roles.map((roleId, index) => `${emoji[index]} <@&${roleId}>`).join("\n")
      );

    const roleMessage = await message.channel.send({ embeds: [embed] });
    for (let i = 0; i < roles.length; i++) {
      await roleMessage.react(emoji[i]);
    }

    const newPanelData = {
      messageId: roleMessage.id,
      roles: roles,
      emojis: emoji.slice(0, roles.length),
      channelId: message.channel.id,
    };

    fs.appendFileSync(rolePanelFile, JSON.stringify(newPanelData) + "\n");

    rolePanelData[roleMessage.id] = newPanelData;
  }
});

client.on("messageCreate", async (message) => {
  if (message.content.startsWith("r.rolepaneladd")) {
    const args = message.content.split(" ");
    if (args.length < 3)
      return message.reply("„É°„ÉÉ„Çª„Éº„Ç∏ID„Å®„É≠„Éº„É´„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");

    const messageId = args[1];
    const roleMentions = message.mentions.roles;
    if (roleMentions.size === 0)
      return message.reply("„É≠„Éº„É´„Çí„É°„É≥„Ç∑„Éß„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ");

    const panelData = rolePanelData[messageId];
    if (!panelData) {
      return message.reply(
        "ÊåáÂÆö„Åï„Çå„Åü„É°„ÉÉ„Çª„Éº„Ç∏ID„ÅÆ„É≠„Éº„É´„Éë„Éç„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"
      );
    }

    const currentEmojiCount = panelData.emojis.length;
    const emojis = [
      "üá¶",
      "üáß",
      "üá®",
      "üá©",
      "üá™",
      "üá´",
      "üá¨",
      "üá≠",
      "üáÆ",
      "üáØ",
      "üá∞",
      "üá±",
      "üá≤",
      "üá≥",
      "üá¥",
      "üáµ",
      "üá∂",
      "üá∑",
      "üá∏",
      "üáπ",
      "üá∫",
      "üáª",
      "üáº",
      "üáΩ",
      "üáæ",
      "üáø",
    ];
    const nextEmoji = emojis[currentEmojiCount];
    if (!nextEmoji) {
      return message.reply("ËøΩÂä†„Åß„Åç„Çã„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ");
    }

    const roleId = roleMentions.first().id;

    try {
      const channel = await client.channels.fetch(panelData.channelId);
      const roleMessage = await channel.messages.fetch(messageId);

      await roleMessage.react(nextEmoji);

      panelData.roles.push(roleId);
      panelData.emojis.push(nextEmoji);

      const embed = roleMessage.embeds[0];
      const updatedEmbed = new MessageEmbed(embed).setDescription(
        panelData.roles
          .map((roleId, index) => `${panelData.emojis[index]} <@&${roleId}>`)
          .join("\n")
      );

      await roleMessage.edit({ embeds: [updatedEmbed] });

      const fileContent = fs.readFileSync(rolePanelFile, "utf8");

      const newFileContent = fileContent
        .split("\n")
        .map((line) => {
          if (line.trim() === "") return line;

          try {
            const data = JSON.parse(line);
            if (data.messageId === messageId) {
              return JSON.stringify(panelData);
            }
            return line;
          } catch (err) {
            console.error("JSON„Éë„Éº„Çπ„Ç®„É©„Éº:", err);
            return line;
          }
        })
        .join("\n");

      fs.writeFileSync(rolePanelFile, newFileContent);

      rolePanelData[messageId] = panelData;

      message.reply(
        `„É°„ÉÉ„Çª„Éº„Ç∏ID ${messageId} „Å´„É≠„Éº„É´„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü„ÄÇ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥: ${nextEmoji}`
      );
    } catch (error) {
      console.error("„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„É≠„Éº„É´„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
      message.reply("„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„É≠„Éº„É´„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
    }
  }
});

const rolePanelFile = "./rolepanel.txt";
let rolePanelData = {};

const emoji = [
  "üá¶",
  "üáß",
  "üá®",
  "üá©",
  "üá™",
  "üá´",
  "üá¨",
  "üá≠",
  "üáÆ",
  "üáØ",
  "üá∞",
  "üá±",
  "üá≤",
  "üá≥",
  "üá¥",
  "üáµ",
  "üá∂",
  "üá∑",
  "üá∏",
  "üáπ",
  "üá∫",
  "üáª",
  "üáº",
  "üáΩ",
  "üáæ",
  "üáø",
];

const emojis = [
  "üá¶",
  "üáß",
  "üá®",
  "üá©",
  "üá™",
  "üá´",
  "üá¨",
  "üá≠",
  "üáÆ",
  "üáØ",
  "üá∞",
  "üá±",
  "üá≤",
  "üá≥",
  "üá¥",
  "üáµ",
  "üá∂",
  "üá∑",
  "üá∏",
  "üáπ",
  "üá∫",
  "üáª",
  "üáº",
  "üáΩ",
  "üáæ",
  "üáø",
];

client.once("ready", async () => {

  if (fs.existsSync(rolePanelFile)) {
    const rawData = fs.readFileSync(rolePanelFile, "utf8");
    const lines = rawData.split("\n").filter((line) => line.trim() !== "");

    for (const line of lines) {
      try {
        const panelData = JSON.parse(line);

        rolePanelData[panelData.messageId] = panelData;

        const channel = await client.channels.fetch(panelData.channelId);
        const roleMessage = await channel.messages.fetch(panelData.messageId);
        console.log("Message fetched and cached:", roleMessage.content);
      } catch (error) {
        console.error("Failed to parse and fetch the role message:", error);
      }
    }
  }
});

client.on("interactionCreate", async (interaction) => {
    if (!interaction.isCommand()) return;
  
    if (interaction.commandName === "rp-create") {
      const role = interaction.options.getRole("role");
      const title = interaction.options.getString("title") || "ÂΩπËÅ∑„Éë„Éç„É´";
      const description = interaction.options.getString("description") || "";
  
      const roles = [role.id];
  
      const embed = new MessageEmbed()
        .setColor("#0099ff")
        .setTitle(title)
        .setDescription(`${emoji[0]} <@&${roles[0]}>\n${description}`);
  
      const roleMessage = await interaction.channel.send({ embeds: [embed] });
      await roleMessage.react(emoji[0]);
  
      const newPanelData = {
        messageId: roleMessage.id,
        roles: roles,
        emojis: emoji.slice(0, roles.length),
        channelId: interaction.channel.id,
      };
  
      fs.appendFileSync(rolePanelFile, JSON.stringify(newPanelData) + "\n");
  
      rolePanelData[roleMessage.id] = newPanelData;
  
      await interaction.reply({
        content: `„É≠„Éº„É´„Éë„Éç„É´„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü`,
        ephemeral: true,
      });
    }
  });

  client.on("interactionCreate", async (interaction) => {
  if (!interaction.isCommand()) return;

  if (interaction.commandName === "rp-add") {
    await interaction.deferReply({ ephemeral: true }); // Âá¶ÁêÜ„ÅÆÈñãÂßã„ÇíÈÄöÁü•

    const messageId = interaction.options.getString("messageid");
    const roles = [
      interaction.options.getRole("role"),
      interaction.options.getRole("role2"),
      interaction.options.getRole("role3"),
      interaction.options.getRole("role4"),
      interaction.options.getRole("role5"),
      interaction.options.getRole("role6"),
      interaction.options.getRole("role7"),
      interaction.options.getRole("role8"),
      interaction.options.getRole("role9"),
      interaction.options.getRole("role10"),
    ].filter(Boolean);

    const panelData = rolePanelData[messageId];
    if (!panelData) {
      return interaction.editReply(
        "ÊåáÂÆö„Åï„Çå„Åü„É°„ÉÉ„Çª„Éº„Ç∏ID„ÅÆ„É≠„Éº„É´„Éë„Éç„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"
      );
    }

    const currentEmojiCount = panelData.emojis.length;
    const nextEmojis = emojis.slice(
      currentEmojiCount,
      currentEmojiCount + roles.length
    );

    try {
      const channel = await client.channels.fetch(panelData.channelId);
      const roleMessage = await channel.messages.fetch(messageId);

      for (let i = 0; i < roles.length; i++) {
        await new Promise((resolve) => setTimeout(resolve, 1000)); // 1Áßí„ÅÆÈÅÖÂª∂„ÇíËøΩÂä†
        await roleMessage.react(nextEmojis[i]);
      }

      panelData.roles.push(...roles.map((role) => role.id));
      panelData.emojis.push(...nextEmojis);

      const embed = roleMessage.embeds[0];
      const updatedEmbed = new MessageEmbed(embed).setDescription(
        panelData.roles
          .map((roleId, index) => `${panelData.emojis[index]} <@&${roleId}>`)
          .join("\n")
      );
      await roleMessage.edit({ embeds: [updatedEmbed] });

      const fileContent = fs.readFileSync(rolePanelFile, "utf8");
      const newFileContent = fileContent
        .split("\n")
        .map((line) => {
          if (line.trim() === "") return line;
          try {
            const data = JSON.parse(line);
            if (data.messageId === messageId) {
              return JSON.stringify(panelData);
            }
            return line;
          } catch (err) {
            console.error("JSON„Éë„Éº„Çπ„Ç®„É©„Éº:", err);
            return line;
          }
        })
        .join("\n");
      fs.writeFileSync(rolePanelFile, newFileContent);

      rolePanelData[messageId] = panelData;

      await interaction.editReply({
        content: `„É≠„Éº„É´„Éë„Éç„É´ID:${messageId}„Å´„É≠„Éº„É´„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü`,
      });
    } catch (error) {
      console.error("„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„É≠„Éº„É´„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
      await interaction.editReply({
        content: `„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„É≠„Éº„É´„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`,
      });
    }
  }
});

  client.on("messageReactionAdd", async (reaction, user) => {
    try {
    if (reaction.message.partial) await reaction.message.fetch();
    const panelData = rolePanelData[reaction.message.id];
    if (!panelData || user.bot) return;
  
    const roleIndex = panelData.emojis.indexOf(reaction.emoji.name);
    if (roleIndex === -1) return;
  
    const roleId = panelData.roles[roleIndex];
    const member = reaction.message.guild.members.cache.get(user.id);
    const role = reaction.message.guild.roles.cache.get(roleId);
  
    if (member.roles.cache.has(roleId)) {
      await member.roles.remove(roleId);
  
      const removeEmbed = new MessageEmbed()
        .setDescription(`<@&${roleId}>„ÅÆ„É≠„Éº„É´„ÇíËß£Èô§„Åó„Åæ„Åó„Åü`)
        .setColor("RANDOM")
        .setTimestamp();
  
      const removeMessage = await reaction.message.channel.send({
        content: `<@${user.id}>`,
        embeds: [removeEmbed],
      });
      setTimeout(() => removeMessage.delete(), 5000);
    } else {
      await member.roles.add(roleId);
  
      const addEmbed = new MessageEmbed()
        .setDescription(`<@&${roleId}>„ÅÆ„É≠„Éº„É´„Çí‰ªò‰∏é„Åó„Åæ„Åó„Åü`)
        .setColor("RANDOM")
        .setTimestamp();
  
      const addMessage = await reaction.message.channel.send({
        content: `<@${user.id}>`,
        embeds: [addEmbed],
      });
      setTimeout(() => addMessage.delete(), 5000);
    }
  
    await reaction.users.remove(user.id);
    } catch (e) {
  console.log(e);
}
  });
//„Åì„Åì„Åæ„Åß
try {
  client.login(process.env.DISCORD_TOKEN);
} catch (e) {
  console.log(e);
}